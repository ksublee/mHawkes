candidate_arrival <- matrix(rexp(4, rate = MU), nrow=2)
current_LAMBDA <- matrix(as.numeric(lambda[k-1, ]), nrow = 2, byrow = TRUE)
# arrival due to components
matrixD <- 1 + BETA * log(runif(4)) / current_LAMBDA
(candidate_arrival <- cbind(candidate_arrival, -1 / BETA * log(pmax(matrixD, 0))))
# The minimum is inter arrival time
inter_arrival[k] <- min(candidate_arrival)
minIndex <- which(candidate_arrival == inter_arrival[k], arr.ind = TRUE) #row and col
(process_type <- minIndex[1])  # row
(jump_type <- minIndex[2]) #col
if (process_type == 1 & (jump_type == 1 | jump_type == 3)){
C1[k] <- C1[k-1] + 1
C2[k] <- C2[k-1]
} else if (process_type == 1 & (jump_type == 2 | jump_type == 4)) {
C1[k] <- C1[k-1] - 1
C2[k] <- C2[k-1]
} else if (process_type == 2 & (jump_type == 1 | jump_type == 3)) {
C1[k] <- C1[k-1]
C2[k] <- C2[k-1] + 1
} else{
C1[k] <- C1[k-1]
C2[k] <- C2[k-1] - 1
}
decayled_lambda <- current_LAMBDA * exp(-BETA * inter_arrival[k])
lambda[k, ] <- t(decayled_lambda)
D[k] <- C1[k] - C2[k]
# if (diff > 0){
#   lambda[k, 2] <- lambda[k, 2] + alpha
#   lambda[k, 3] <- lambda[k, 3] + alpha2
# } else if(diff < 0 ) {
#   lambda[k, 1] <- lambda[k, 1] + alpha
#   lambda[k, 4] <- lambda[k, 4] + alpha2
# }
Dp[k] <- max(D[k], 0)
Dn[k] <- -min(D[k], 0)
if ( D[k]>0 ){
lambda[k, 2] <- lambda[k, 2] + alpha
lambda[k, 3] <- lambda[k, 3] + alpha2
} else if( D[k]<0 ) {
lambda[k, 1] <- lambda[k, 1] + alpha
lambda[k, 4] <- lambda[k, 4] + alpha2
}
}
res <- matrix(cbind(cumsum(inter_arrival), C1, C2), ncol = 3)
plot(cumsum(inter_arrival), C1, 's')
lines(cumsum(inter_arrival), C2, 's', col='red')
#plot(cumsum(inter_arrival), lambda[,1], 'l')
#lines(cumsum(inter_arrival), lambda[,3], 'l', col='red')
n1 <- n2 <- 0
for (k in 2:n) {
if (C1[k] != C1[k-1] ) n1 <- n1 + 1
if (C2[k] != C2[k-1] ) n2 <- n2 + 1
}
plot(cumsum(inter_arrival[1:100]), lambda[1:100,1]-lambda[1:100,2], 'l')
lines(cumsum(inter_arrival[1:100]), 10*(C1[1:100]-C2[1:100]), 's', col='red')
#plot(C1- C2, lambda[,1] - lambda[,2])
plot(Dp)
plot(Dp, 's')
plot(cumsum(inter_arrival), Dp, 's')
plot(cumsum(inter_arrival), Dn, 's')
rm(list=ls())
n <- 1000
C1 <- C2 <- lambda1_u <- lambda1_d <- lambda2_u <- lambda2_d <- inter_arrival <- D <- Dp <- Dn <- numeric(n)
MU <- matrix(c(10, 10, 10, 10), nrow = 2)
lambda <-  matrix(sapply(c(10, 10, 10, 10), c, numeric(length = n - 1)), ncol = 4)
#lambda1_u[1] <- lambda1_d[1] <- MU[1,1]
#lambda2_u[1] <- lambda2_d[1] <- MU[2]
C1[1] <- C2[1] <- 0
alpha <- 10
alpha2 <- 10
beta <- 20
ALPHA <- matrix(rep(alpha, 4), nrow = 2)
BETA <- matrix(rep(beta, 4), nrow = 2)
for (k in 2:n) {
# Generate candidate arrivals
# arrival due to mu
candidate_arrival <- matrix(rexp(4, rate = MU), nrow=2)
current_LAMBDA <- matrix(as.numeric(lambda[k-1, ]), nrow = 2, byrow = TRUE)
# arrival due to components
matrixD <- 1 + BETA * log(runif(4)) / current_LAMBDA
(candidate_arrival <- cbind(candidate_arrival, -1 / BETA * log(pmax(matrixD, 0))))
# The minimum is inter arrival time
inter_arrival[k] <- min(candidate_arrival)
minIndex <- which(candidate_arrival == inter_arrival[k], arr.ind = TRUE) #row and col
(process_type <- minIndex[1])  # row
(jump_type <- minIndex[2]) #col
if (process_type == 1 & (jump_type == 1 | jump_type == 3)){
C1[k] <- C1[k-1] + 1
C2[k] <- C2[k-1]
} else if (process_type == 1 & (jump_type == 2 | jump_type == 4)) {
C1[k] <- C1[k-1] - 1
C2[k] <- C2[k-1]
} else if (process_type == 2 & (jump_type == 1 | jump_type == 3)) {
C1[k] <- C1[k-1]
C2[k] <- C2[k-1] + 1
} else{
C1[k] <- C1[k-1]
C2[k] <- C2[k-1] - 1
}
decayled_lambda <- current_LAMBDA * exp(-BETA * inter_arrival[k])
lambda[k, ] <- t(decayled_lambda)
D[k] <- C1[k] - C2[k]
# if (diff > 0){
#   lambda[k, 2] <- lambda[k, 2] + alpha
#   lambda[k, 3] <- lambda[k, 3] + alpha2
# } else if(diff < 0 ) {
#   lambda[k, 1] <- lambda[k, 1] + alpha
#   lambda[k, 4] <- lambda[k, 4] + alpha2
# }
Dp[k] <- max(D[k], 0)
Dn[k] <- -min(D[k], 0)
if ( D[k]>0 ){
lambda[k, 2] <- lambda[k, 2] + alpha*(Dp[k] - Dp[k-1])
lambda[k, 3] <- lambda[k, 3] + alpha2*(Dp[k] - Dp[k-1])
} else if( D[k]<0 ) {
lambda[k, 1] <- lambda[k, 1] + alpha*(Dn[k] - Dn[k-1])
lambda[k, 4] <- lambda[k, 4] + alpha2*(Dn[k] - Dn[k-1])
}
}
res <- matrix(cbind(cumsum(inter_arrival), C1, C2), ncol = 3)
plot(cumsum(inter_arrival), C1, 's')
lines(cumsum(inter_arrival), C2, 's', col='red')
#plot(cumsum(inter_arrival), lambda[,1], 'l')
#lines(cumsum(inter_arrival), lambda[,3], 'l', col='red')
n1 <- n2 <- 0
for (k in 2:n) {
if (C1[k] != C1[k-1] ) n1 <- n1 + 1
if (C2[k] != C2[k-1] ) n2 <- n2 + 1
}
plot(cumsum(inter_arrival[1:100]), lambda[1:100,1]-lambda[1:100,2], 'l')
lines(cumsum(inter_arrival[1:100]), 10*(C1[1:100]-C2[1:100]), 's', col='red')
#plot(C1- C2, lambda[,1] - lambda[,2])
rm(list=ls())
n <- 1000
C1 <- C2 <- lambda1_u <- lambda1_d <- lambda2_u <- lambda2_d <- inter_arrival <- D <- Dp <- Dn <- numeric(n)
MU <- matrix(c(10, 10, 10, 10), nrow = 2)
lambda <-  matrix(sapply(c(10, 10, 10, 10), c, numeric(length = n - 1)), ncol = 4)
#lambda1_u[1] <- lambda1_d[1] <- MU[1,1]
#lambda2_u[1] <- lambda2_d[1] <- MU[2]
C1[1] <- C2[1] <- 0
alpha <- 10
alpha2 <- 10
beta <- 20
ALPHA <- matrix(rep(alpha, 4), nrow = 2)
BETA <- matrix(rep(beta, 4), nrow = 2)
for (k in 2:n) {
# Generate candidate arrivals
# arrival due to mu
candidate_arrival <- matrix(rexp(4, rate = MU), nrow=2)
current_LAMBDA <- matrix(as.numeric(lambda[k-1, ]), nrow = 2, byrow = TRUE)
# arrival due to components
matrixD <- 1 + BETA * log(runif(4)) / current_LAMBDA
(candidate_arrival <- cbind(candidate_arrival, -1 / BETA * log(pmax(matrixD, 0))))
# The minimum is inter arrival time
inter_arrival[k] <- min(candidate_arrival)
minIndex <- which(candidate_arrival == inter_arrival[k], arr.ind = TRUE) #row and col
(process_type <- minIndex[1])  # row
(jump_type <- minIndex[2]) #col
if (process_type == 1 & (jump_type == 1 | jump_type == 3)){
C1[k] <- C1[k-1] + 1
C2[k] <- C2[k-1]
} else if (process_type == 1 & (jump_type == 2 | jump_type == 4)) {
C1[k] <- C1[k-1] - 1
C2[k] <- C2[k-1]
} else if (process_type == 2 & (jump_type == 1 | jump_type == 3)) {
C1[k] <- C1[k-1]
C2[k] <- C2[k-1] + 1
} else{
C1[k] <- C1[k-1]
C2[k] <- C2[k-1] - 1
}
decayled_lambda <- current_LAMBDA * exp(-BETA * inter_arrival[k])
lambda[k, ] <- t(decayled_lambda)
D[k] <- C1[k] - C2[k]
# if (diff > 0){
#   lambda[k, 2] <- lambda[k, 2] + alpha
#   lambda[k, 3] <- lambda[k, 3] + alpha2
# } else if(diff < 0 ) {
#   lambda[k, 1] <- lambda[k, 1] + alpha
#   lambda[k, 4] <- lambda[k, 4] + alpha2
# }
Dp[k] <- max(D[k], 0)
Dn[k] <- -min(D[k], 0)
if ( D[k]>0 ){
lambda[k, 2] <- lambda[k, 2] + alpha*abs(Dp[k] - Dp[k-1])
lambda[k, 3] <- lambda[k, 3] + alpha2*abs(Dp[k] - Dp[k-1])
} else if( D[k]<0 ) {
lambda[k, 1] <- lambda[k, 1] + alpha*abs(Dn[k] - Dn[k-1])
lambda[k, 4] <- lambda[k, 4] + alpha2*abs(Dn[k] - Dn[k-1])
}
}
res <- matrix(cbind(cumsum(inter_arrival), C1, C2), ncol = 3)
plot(cumsum(inter_arrival), C1, 's')
lines(cumsum(inter_arrival), C2, 's', col='red')
#plot(cumsum(inter_arrival), lambda[,1], 'l')
#lines(cumsum(inter_arrival), lambda[,3], 'l', col='red')
n1 <- n2 <- 0
for (k in 2:n) {
if (C1[k] != C1[k-1] ) n1 <- n1 + 1
if (C2[k] != C2[k-1] ) n2 <- n2 + 1
}
plot(cumsum(inter_arrival[1:100]), lambda[1:100,1]-lambda[1:100,2], 'l')
lines(cumsum(inter_arrival[1:100]), 10*(C1[1:100]-C2[1:100]), 's', col='red')
#plot(C1- C2, lambda[,1] - lambda[,2])
plot(cumsum(inter_arrival), C1, 's')
lines(cumsum(inter_arrival), C2, 's', col='red')
rm(list=ls())
n <- 1000
C1 <- C2 <- lambda1_u <- lambda1_d <- lambda2_u <- lambda2_d <- inter_arrival <- D <- Dp <- Dn <- numeric(n)
MU <- matrix(c(10, 10, 10, 10), nrow = 2)
lambda <-  matrix(sapply(c(10, 10, 10, 10), c, numeric(length = n - 1)), ncol = 4)
#lambda1_u[1] <- lambda1_d[1] <- MU[1,1]
#lambda2_u[1] <- lambda2_d[1] <- MU[2]
C1[1] <- C2[1] <- 0
alpha <- 10
alpha2 <- 10
beta <- 20
ALPHA <- matrix(rep(alpha, 4), nrow = 2)
BETA <- matrix(rep(beta, 4), nrow = 2)
for (k in 2:n) {
# Generate candidate arrivals
# arrival due to mu
candidate_arrival <- matrix(rexp(4, rate = MU), nrow=2)
current_LAMBDA <- matrix(as.numeric(lambda[k-1, ]), nrow = 2, byrow = TRUE)
# arrival due to components
matrixD <- 1 + BETA * log(runif(4)) / current_LAMBDA
(candidate_arrival <- cbind(candidate_arrival, -1 / BETA * log(pmax(matrixD, 0))))
# The minimum is inter arrival time
inter_arrival[k] <- min(candidate_arrival)
minIndex <- which(candidate_arrival == inter_arrival[k], arr.ind = TRUE) #row and col
(process_type <- minIndex[1])  # row
(jump_type <- minIndex[2]) #col
if (process_type == 1 & (jump_type == 1 | jump_type == 3)){
C1[k] <- C1[k-1] + 1
C2[k] <- C2[k-1]
} else if (process_type == 1 & (jump_type == 2 | jump_type == 4)) {
C1[k] <- C1[k-1] - 1
C2[k] <- C2[k-1]
} else if (process_type == 2 & (jump_type == 1 | jump_type == 3)) {
C1[k] <- C1[k-1]
C2[k] <- C2[k-1] + 1
} else{
C1[k] <- C1[k-1]
C2[k] <- C2[k-1] - 1
}
decayled_lambda <- current_LAMBDA * exp(-BETA * inter_arrival[k])
lambda[k, ] <- t(decayled_lambda)
D[k] <- C1[k] - C2[k]
# if (diff > 0){
#   lambda[k, 2] <- lambda[k, 2] + alpha
#   lambda[k, 3] <- lambda[k, 3] + alpha2
# } else if(diff < 0 ) {
#   lambda[k, 1] <- lambda[k, 1] + alpha
#   lambda[k, 4] <- lambda[k, 4] + alpha2
# }
Dp[k] <- max(D[k], 0)
Dn[k] <- -min(D[k], 0)
if ( D[k]>0 ){
lambda[k, 2] <- lambda[k, 2] + alpha*max(Dp[k] - Dp[k-1], 0)
lambda[k, 3] <- lambda[k, 3] + alpha2*max(Dp[k] - Dp[k-1], 0)
} else if( D[k]<0 ) {
lambda[k, 1] <- lambda[k, 1] + alpha*max(Dn[k] - Dn[k-1], 0)
lambda[k, 4] <- lambda[k, 4] + alpha2*max(Dn[k] - Dn[k-1], 0)
}
}
res <- matrix(cbind(cumsum(inter_arrival), C1, C2), ncol = 3)
plot(cumsum(inter_arrival), C1, 's')
lines(cumsum(inter_arrival), C2, 's', col='red')
#plot(cumsum(inter_arrival), lambda[,1], 'l')
#lines(cumsum(inter_arrival), lambda[,3], 'l', col='red')
n1 <- n2 <- 0
for (k in 2:n) {
if (C1[k] != C1[k-1] ) n1 <- n1 + 1
if (C2[k] != C2[k-1] ) n2 <- n2 + 1
}
plot(cumsum(inter_arrival[1:100]), lambda[1:100,1]-lambda[1:100,2], 'l')
lines(cumsum(inter_arrival[1:100]), 10*(C1[1:100]-C2[1:100]), 's', col='red')
#plot(C1- C2, lambda[,1] - lambda[,2])
plot(cumsum(inter_arrival), C1, 's')
lines(cumsum(inter_arrival), C2, 's', col='red')
rm(list=ls())
n <- 1000
C1 <- C2 <- lambda1_u <- lambda1_d <- lambda2_u <- lambda2_d <- inter_arrival <- D <- Dp <- Dn <- numeric(n)
MU <- matrix(c(10, 10, 10, 10), nrow = 2)
lambda <-  matrix(sapply(c(10, 10, 10, 10), c, numeric(length = n - 1)), ncol = 4)
#lambda1_u[1] <- lambda1_d[1] <- MU[1,1]
#lambda2_u[1] <- lambda2_d[1] <- MU[2]
C1[1] <- C2[1] <- 0
alpha <- 10
alpha2 <- 10
beta <- 20
ALPHA <- matrix(rep(alpha, 4), nrow = 2)
BETA <- matrix(rep(beta, 4), nrow = 2)
for (k in 2:n) {
# Generate candidate arrivals
# arrival due to mu
candidate_arrival <- matrix(rexp(4, rate = MU), nrow=2)
current_LAMBDA <- matrix(as.numeric(lambda[k-1, ]), nrow = 2, byrow = TRUE)
# arrival due to components
matrixD <- 1 + BETA * log(runif(4)) / current_LAMBDA
(candidate_arrival <- cbind(candidate_arrival, -1 / BETA * log(pmax(matrixD, 0))))
# The minimum is inter arrival time
inter_arrival[k] <- min(candidate_arrival)
minIndex <- which(candidate_arrival == inter_arrival[k], arr.ind = TRUE) #row and col
(process_type <- minIndex[1])  # row
(jump_type <- minIndex[2]) #col
if (process_type == 1 & (jump_type == 1 | jump_type == 3)){
C1[k] <- C1[k-1] + 1
C2[k] <- C2[k-1]
} else if (process_type == 1 & (jump_type == 2 | jump_type == 4)) {
C1[k] <- C1[k-1] - 1
C2[k] <- C2[k-1]
} else if (process_type == 2 & (jump_type == 1 | jump_type == 3)) {
C1[k] <- C1[k-1]
C2[k] <- C2[k-1] + 1
} else{
C1[k] <- C1[k-1]
C2[k] <- C2[k-1] - 1
}
decayled_lambda <- current_LAMBDA * exp(-BETA * inter_arrival[k])
lambda[k, ] <- t(decayled_lambda)
D[k] <- C1[k] - C2[k]
# if (diff > 0){
#   lambda[k, 2] <- lambda[k, 2] + alpha
#   lambda[k, 3] <- lambda[k, 3] + alpha2
# } else if(diff < 0 ) {
#   lambda[k, 1] <- lambda[k, 1] + alpha
#   lambda[k, 4] <- lambda[k, 4] + alpha2
# }
Dp[k] <- max(D[k], 0)
Dn[k] <- -min(D[k], 0)
if ( D[k]>0 ){
lambda[k, 1] <- 10
lambda[k, 2] <- 30
lambda[k, 3] <- 30
lambda[k, 4] <- 10
} else if( D[k]<0 ) {
lambda[k, 1] <- 30
lambda[k, 2] <- 10
lambda[k, 3] <- 10
lambda[k, 4] <- 30
}
}
res <- matrix(cbind(cumsum(inter_arrival), C1, C2), ncol = 3)
plot(cumsum(inter_arrival), C1, 's')
lines(cumsum(inter_arrival), C2, 's', col='red')
#plot(cumsum(inter_arrival), lambda[,1], 'l')
#lines(cumsum(inter_arrival), lambda[,3], 'l', col='red')
n1 <- n2 <- 0
for (k in 2:n) {
if (C1[k] != C1[k-1] ) n1 <- n1 + 1
if (C2[k] != C2[k-1] ) n2 <- n2 + 1
}
plot(cumsum(inter_arrival[1:100]), lambda[1:100,1]-lambda[1:100,2], 'l')
lines(cumsum(inter_arrival[1:100]), 10*(C1[1:100]-C2[1:100]), 's', col='red')
#plot(C1- C2, lambda[,1] - lambda[,2])
plot(cumsum(inter_arrival), C1, 's')
lines(cumsum(inter_arrival), C2, 's', col='red')
plot(cumsum(inter_arrival[1:100]), lambda[1:100,1]-lambda[1:100,2], 'l')
lines(cumsum(inter_arrival[1:100]), 10*(C1[1:100]-C2[1:100]), 's', col='red')
plot(cumsum(inter_arrival[1:100]), lambda[1:100,1]-lambda[1:100,2], 'l')
lines(cumsum(inter_arrival[1:100]), 5*(C1[1:100]-C2[1:100]), 's', col='red')
plot(cumsum(inter_arrival[1:100]), lambda[1:100,1]-lambda[1:100,2], 's')
lines(cumsum(inter_arrival[1:100]), 10*(C1[1:100]-C2[1:100]), 's', col='red')
rm(list=ls())
n <- 1000
C1 <- C2 <- lambda1_u <- lambda1_d <- lambda2_u <- lambda2_d <- inter_arrival <- D <- Dp <- Dn <- numeric(n)
MU <- matrix(c(10, 10, 10, 10), nrow = 2)
lambda <-  matrix(sapply(c(10, 10, 10, 10), c, numeric(length = n - 1)), ncol = 4)
#lambda1_u[1] <- lambda1_d[1] <- MU[1,1]
#lambda2_u[1] <- lambda2_d[1] <- MU[2]
C1[1] <- C2[1] <- 0
alpha <- 10
alpha2 <- 10
beta <- 20
ALPHA <- matrix(rep(alpha, 4), nrow = 2)
BETA <- matrix(rep(beta, 4), nrow = 2)
for (k in 2:n) {
# Generate candidate arrivals
# arrival due to mu
candidate_arrival <- matrix(rexp(4, rate = MU), nrow=2)
current_LAMBDA <- matrix(as.numeric(lambda[k-1, ]), nrow = 2, byrow = TRUE)
# arrival due to components
matrixD <- 1 + BETA * log(runif(4)) / current_LAMBDA
(candidate_arrival <- cbind(candidate_arrival, -1 / BETA * log(pmax(matrixD, 0))))
# The minimum is inter arrival time
inter_arrival[k] <- min(candidate_arrival)
minIndex <- which(candidate_arrival == inter_arrival[k], arr.ind = TRUE) #row and col
(process_type <- minIndex[1])  # row
(jump_type <- minIndex[2]) #col
if (process_type == 1 & (jump_type == 1 | jump_type == 3)){
C1[k] <- C1[k-1] + 1
C2[k] <- C2[k-1]
} else if (process_type == 1 & (jump_type == 2 | jump_type == 4)) {
C1[k] <- C1[k-1] - 1
C2[k] <- C2[k-1]
} else if (process_type == 2 & (jump_type == 1 | jump_type == 3)) {
C1[k] <- C1[k-1]
C2[k] <- C2[k-1] + 1
} else{
C1[k] <- C1[k-1]
C2[k] <- C2[k-1] - 1
}
decayled_lambda <- current_LAMBDA * exp(-BETA * inter_arrival[k])
lambda[k, ] <- t(decayled_lambda)
D[k] <- C1[k] - C2[k]
# if (diff > 0){
#   lambda[k, 2] <- lambda[k, 2] + alpha
#   lambda[k, 3] <- lambda[k, 3] + alpha2
# } else if(diff < 0 ) {
#   lambda[k, 1] <- lambda[k, 1] + alpha
#   lambda[k, 4] <- lambda[k, 4] + alpha2
# }
Dp[k] <- max(D[k], 0)
Dn[k] <- -min(D[k], 0)
if ( D[k]>0 ){
lambda[k, 1] <- 10
lambda[k, 2] <- 20
lambda[k, 3] <- 20
lambda[k, 4] <- 10
} else if( D[k]<0 ) {
lambda[k, 1] <- 20
lambda[k, 2] <- 10
lambda[k, 3] <- 10
lambda[k, 4] <- 20
}
}
res <- matrix(cbind(cumsum(inter_arrival), C1, C2), ncol = 3)
plot(cumsum(inter_arrival), C1, 's')
lines(cumsum(inter_arrival), C2, 's', col='red')
#plot(cumsum(inter_arrival), lambda[,1], 'l')
#lines(cumsum(inter_arrival), lambda[,3], 'l', col='red')
n1 <- n2 <- 0
for (k in 2:n) {
if (C1[k] != C1[k-1] ) n1 <- n1 + 1
if (C2[k] != C2[k-1] ) n2 <- n2 + 1
}
plot(cumsum(inter_arrival[1:100]), lambda[1:100,1]-lambda[1:100,2], 's')
lines(cumsum(inter_arrival[1:100]), 10*(C1[1:100]-C2[1:100]), 's', col='red')
#plot(C1- C2, lambda[,1] - lambda[,2])
plot(cumsum(inter_arrival), C1, 's')
lines(cumsum(inter_arrival), C2, 's', col='red')
library(dplyr, ggplot2)
library(babynames)
install.packages(babynames)
install.packages("babynames")
library(babynames)
topNames_tbl <- babyname %>%
filter(year >= 1986) %>%
group_by(name, sex) %>%
summarize(count = as.numeric(sum(n))) %>%
filter(count > 1000) %>%
select(name, sex)
topNames_tbl <- babynames %>%
filter(year >= 1986) %>%
group_by(name, sex) %>%
summarize(count = as.numeric(sum(n))) %>%
filter(count > 1000) %>%
select(name, sex)
babynames
babynames_tbl <- babynames
filteredNames_tbl <- babynames_tbl %>%
filter(year >= 1986) %>%
inner_join(topNames_tbl)
yearlyNames_tbl <- filteredNames_tbl %>%
group_by(year, name, sex) %>%
summarize(count = as.numeric(sum(n)))
topNames1986_tbl <- yearlyNames_tbl %>%
filter(year == 1986) %>%
group_by(name, sex) %>%
summarize(count = sum(count)) %>%
group_by(sex) %>%
mutate(rank = min_rank(desc(count))) %>%
filter(rank < 5) %>%
arrange(sex, rank) %>%
select(name, sex, rank)
topNames1986Yearly <- yearlyNames_tbl %>%
inner_join(select(topNames1986_tbl, sex, name))
ggplot(topNames1986Yearly, aes(year, count, color=name)) +
facet_grid(~sex) +
geom_line() +
ggtitle("Most Popular Names of 1986")
library(ggplot2)
ggplot(topNames1986Yearly, aes(year, count, color=name)) +
facet_grid(~sex) +
geom_line() +
ggtitle("Most Popular Names of 1986")
library(sparklyr)
library(babynames)
library(ggplot2)
install.packages("sparklyr")
install.packages("sparklyr")
install.packages("sparklyr")
install.packages("sparklyr")
install.packages("sparklyr")
install.packages("sparklyr")
library(sparklyr)
install.packages("tibble")
install.packages("tibble")
library(sparklyr)
library(babynames)
library(ggplot2)
sc <- spark_connect(master = "local", version = "2.0.0")
spark_install(version = "2.0.0")
sc <- spark_connect(master = "local", version = "2.0.0")
spark_install(version = "2.0.0")
sc <- spark_connect(master = "local", version = "2.0.0")
library(sparklyr)
library(babynames)
library(ggplot2)
spark_install(version = "2.0.0")
sc <- spark_connect(master = "local", version = "2.0.0")
